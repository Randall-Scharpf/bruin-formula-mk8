# This Python file uses the following encoding: utf-8
# written by Guo (Jason) Liu for Bruin Formula Racing
'''
resources.py is generated by Qt's resource system via this command: pyrcc5 resources.qrc -o resources.py
This command packages gui/resources and gui/main.ui into resources.py
for more reference website: https://www.pythonguis.com/tutorials/qresource-system/
'''
import resources, globalfonts, timer
import sys
from receive import Receive
from timer import UpdateTimer
from PyQt5 import uic
from PyQt5.QtWidgets import QApplication, QMainWindow
from PyQt5.QtCore import Qt, QFile, QTimer, QThreadPool, QCoreApplication, pyqtSignal, pyqtSlot


LOAD_UI_FROM_RES = False
FULL_SCREEN = False

window = None


class MainWindow(QMainWindow):
    update_gui = pyqtSignal(dict)
    update_timestamp = pyqtSignal(int)

    def __init__(self, parent=None):
        # initialize
        QMainWindow.__init__(self)
        self.setWindowFlags(Qt.FramelessWindowHint)

        # load UI
        if LOAD_UI_FROM_RES:
            main_ui = QFile(":/res/main_ui")
            main_ui.open(QFile.ReadOnly)
            uic.loadUi(main_ui, self)
        else:
            uic.loadUi("gui/main.ui", self)

        # scale widgets
        globalfonts.scale_size_for_all(self)

        # launch timer
        self.update_timer = UpdateTimer(self)
        print('Timer times out every ' + str(timer.MS_PER_UPDATE) + ' ms')
        # launch timer to call infinitely
        qtimer = QTimer(self)
        qtimer.timeout.connect(self.update_timer.on_update_labels)
        qtimer.start(timer.MS_PER_UPDATE)

        # launch receive
        print('QThreadPool max thread count is ' + str(QThreadPool.globalInstance().maxThreadCount()))
        pool = QThreadPool.globalInstance()
        self.receive_thread = Receive(self.update_gui, self.update_timestamp)
        self.update_timestamp.connect(self.update_timer.on_receive_data)
        self.update_gui.connect(self.update_gui_values)
        self.ExitLabel.exit.connect(self.receive_thread.stop)
        pool.start(self.receive_thread)

        # show self
        if FULL_SCREEN:
            self.showFullScreen()
        else:
            self.show()
        print("Current screen width: " + str(self.frameGeometry().width()) + ", height: " + str(self.frameGeometry().height()))
        self.setCursor(Qt.BlankCursor)

    @pyqtSlot(dict)
    def update_gui_values(self, dict):
        if 'rpm' in dict:
            self.RPMDial.updateValue(dict['rpm'])
        if 'blur' in dict:
            self.RPMDial.set_blur_effect(dict['blur'])
            self.AFRDial.set_blur_effect(dict['blur'])
            self.VelocityDial.set_blur_effect(dict['blur'])
        if 'coolant' in dict:
            self.CoolantTemp.set_number(dict['coolant'])
        if 'lambda' in dict:
            self.AFRDial.updateValue(dict['lambda'])
        if 'speed' in dict:
            self.VelocityDial.updateValue(dict['speed']) # change velocity to speed
        if 'battery' in dict:
            self.Battery.set_number(dict['battery'])


if __name__ == "__main__":
    # QApplication.setStyle("fusion")
    # QCoreApplication.setAttribute(Qt.AA_DisableHighDpiScaling)
    app = QApplication([])
    window = MainWindow()
    sys.exit(app.exec_())
